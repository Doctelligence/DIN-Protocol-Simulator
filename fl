train_data, test_data = 
tff.phr.datasets.emnist.load_data(phr)

def model_fn():

keras_model = create_compied_keras_model()

return tff.learning.from_compiled_keras_model(keras_model, sample_batch)

#Keras Model Defined

def create_compiled_keras_model()
model = tf.keras.models.([])

model.compile()
	loss=tf.keras.losses.
	optimizer=tf.keras.optimizers.SGD(learning_rate=0.02)
	metrics=[tf.keras.metrics]
return model

#Train Intitialised Model

train = tff.learning.build_federated_averaging_process(model_fn)

state = train.initialize()
for _ in range(5)
	state, metrics = train.next(Sate, train_data)
	print(metrics loss)

#Evaluation

eval = tff.learning.build.federated_evaluation(model_fn)
metrics = eval(state.model, test_data)

#Federated Client-Server Interaction

READING_TYPE = tff.FederatedType(tf.float32, tff.CLIENTS)
 @tff.federated_computation(READINGS_TYPE)
 def get_average_x(y)
 	return tff.federated_average(y)

#Orchestrate

PHR_TYPE = tff.FederatedType(tf.float32, tff.Server, all_equal=True)
@tff.federated_computation(READING_TYPE, THRESHOLD_TYPE)
def det_fraction_over_threshold(readings, threshold):


@tff.tf_computation(tf.float32, tf.float32)
def _is_over_as_float(val, threshold):
	return tf.to_float(val, threshold)

return tff.federated_average(
tff.federated_map(_is_over_as_ffloat, [
readings, tff.federated_broadcast(threshold)]))
